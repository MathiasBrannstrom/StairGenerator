<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stair Generator - Web Version</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            display: flex;
            height: 100vh;
            background-color: #f5f5f5;
        }

        .controls-panel {
            width: 270px;
            background-color: #f5f5f5;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #ddd;
        }

        .viewport {
            flex: 1;
            background-color: white;
            position: relative;
        }

        #renderer {
            width: 100%;
            height: 100%;
        }

        h1 {
            font-size: 16px;
            font-weight: bold;
            margin: 0 0 20px 0;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: normal;
        }

        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 5px;
            border: 1px solid #ccc;
            border-radius: 3px;
            box-sizing: border-box;
        }

        input[type="checkbox"] {
            margin-right: 5px;
        }

        button {
            padding: 10px 15px;
            margin: 5px 0;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 14px;
            width: 100%;
        }

        .generate-btn {
            background-color: #4CAF50;
            color: white;
        }

        .export-btn {
            background-color: #2196F3;
            color: white;
        }

        .add-btn {
            background-color: #FF9800;
            color: white;
            width: auto;
            margin-right: 10px;
        }

        .remove-btn {
            background-color: #F44336;
            color: white;
            width: auto;
        }

        .level-container {
            border: 1px solid #ddd;
            padding: 10px;
            margin: 5px 0;
            border-radius: 3px;
            background-color: white;
        }

        .level-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .level-controls input {
            width: 60px;
        }

        .status {
            margin-top: 20px;
            padding: 10px;
            background-color: #e8f5e8;
            border-radius: 3px;
            font-size: 12px;
        }

        .info-text {
            font-style: italic;
            font-size: 12px;
            color: #666;
            margin-bottom: 10px;
        }

        .calculated-info {
            font-weight: bold;
            margin-top: 10px;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="controls-panel">
        <h1>Stair Generator</h1>

        <div class="info-text">Stairs with landings (forward/backward)</div>

        <div class="input-group">
            <label for="stairwellHeight">Stairwell Height (mm):</label>
            <input type="number" id="stairwellHeight" value="2700">
        </div>

        <div class="input-group">
            <label for="stepLength">Step Length (mm):</label>
            <input type="number" id="stepLength" value="280">
        </div>

        <div class="input-group">
            <label for="stairWidth">Stair Width (mm):</label>
            <input type="number" id="stairWidth" value="1000">
        </div>

        <div class="input-group">
            <label for="platformWidth">Platform Width (mm):</label>
            <input type="number" id="platformWidth" value="3000">
        </div>

        <div class="input-group">
            <label for="platformDepth">Platform Depth (mm):</label>
            <input type="number" id="platformDepth" value="1500">
        </div>

        <div class="input-group">
            <label>
                <input type="checkbox" id="clockwise" checked>
                Clockwise going up
            </label>
        </div>

        <div class="input-group">
            <label><strong>Stair Levels:</strong></label>
            <div id="levelsContainer"></div>
            <div style="margin-top: 10px;">
                <button class="add-btn" onclick="addLevel()">Add Level</button>
                <button class="remove-btn" onclick="removeLevel()">Remove Level</button>
            </div>
        </div>

        <div class="calculated-info" id="calculatedInfo">
            Total Steps: 16 steps, 1 platforms<br>
            Calculated Step Height: 150.0 mm
        </div>

        <button class="generate-btn" onclick="generateStair()">Generate Stair</button>
        <button class="export-btn" onclick="exportOBJ()">Export OBJ</button>

        <div class="status" id="status">Ready</div>
    </div>

    <div class="viewport">
        <div id="renderer"></div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let stairMesh = null;
        let stairLevels = [
            { stepCount: 8 },
            { stepCount: 8 }
        ];

        // Initialize Three.js scene
        function initThreeJS() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xffffff);

            // Camera
            camera = new THREE.PerspectiveCamera(60, 1, 0.1, 1000);
            camera.position.set(5, 5, 5);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(800, 600);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            document.getElementById('renderer').appendChild(renderer.domElement);

            // Controls
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            // Coordinate axes
            const axesHelper = new THREE.AxesHelper(1);
            scene.add(axesHelper);

            // Handle window resize
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize(); // Set initial size

            animate();
        }

        function onWindowResize() {
            const container = document.getElementById('renderer');
            const width = container.clientWidth;
            const height = container.clientHeight;

            camera.aspect = width / height;
            camera.updateProjectionMatrix();

            renderer.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        // Stair generation logic (ported from C#)
        function generateLinearStairwellMesh(stairLevels, stepHeight, stepLength, stairWidth, platformWidth, platformDepth, clockwise = true) {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const indices = [];
            const normals = [];

            // Convert to meters for display
            stepHeight /= 1000.0;
            stepLength /= 1000.0;
            stairWidth /= 1000.0;
            platformWidth /= 1000.0;
            platformDepth /= 1000.0;

            let currentZ = 0;
            let currentY = 0;

            for (let levelIndex = 0; levelIndex < stairLevels.length; levelIndex++) {
                const level = stairLevels[levelIndex];
                const isForward = levelIndex % 2 === 0;

                // Determine side based on clockwise parameter
                const isLeftSide = clockwise ? (levelIndex % 2 === 1) : (levelIndex % 2 === 0);

                // Calculate stair starting position
                const stairStartX = isLeftSide ? 0 : (platformWidth - stairWidth);

                // For stairs after the first level, adjust starting Z position
                let stairStartZ = currentZ;
                if (levelIndex > 0) {
                    if (isForward) {
                        stairStartZ = currentZ + platformDepth;
                    } else {
                        stairStartZ = currentZ - platformDepth;
                    }
                }

                // Generate stairs for this level
                generateStairLevel(positions, indices, normals, stairStartX, stairStartZ, currentY, level.stepCount, stepHeight, stepLength, stairWidth, isForward);

                // Update position after stairs
                if (isForward) {
                    currentZ = stairStartZ + level.stepCount * stepLength;
                } else {
                    currentZ = stairStartZ - level.stepCount * stepLength;
                }

                currentY += level.stepCount * stepHeight;

                // Generate platform after stairs (except for last level)
                if (levelIndex < stairLevels.length - 1) {
                    const platformY = currentY + stepHeight;
                    generatePlatform(positions, indices, normals, currentZ, platformY, platformWidth, platformDepth, stepHeight, isForward);

                    if (isForward) {
                        currentZ += platformDepth;
                    } else {
                        currentZ -= platformDepth;
                    }
                }

                currentY += stepHeight;
            }

            // Convert arrays to Float32Array for Three.js
            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));

            return geometry;
        }

        function generateStairLevel(positions, indices, normals, startX, startZ, startY, stepCount, stepHeight, stepLength, stairWidth, isForward) {
            for (let step = 0; step < stepCount; step++) {
                const currentHeight = startY + step * stepHeight;
                const nextHeight = startY + (step + 1) * stepHeight;

                let currentDepth, nextDepth;
                if (isForward) {
                    currentDepth = startZ + step * stepLength;
                    nextDepth = startZ + (step + 1) * stepLength;
                } else {
                    currentDepth = startZ - step * stepLength;
                    nextDepth = startZ - (step + 1) * stepLength;
                }

                addStepToMesh(positions, indices, normals, currentHeight, nextHeight, currentDepth, nextDepth, stairWidth, startX, isForward);
            }
        }

        function generatePlatform(positions, indices, normals, startZ, startY, platformWidth, platformDepth, stepHeight, previousWasForward) {
            const baseIndex = positions.length / 3;

            const endZ = previousWasForward ? startZ + platformDepth : startZ - platformDepth;
            const minZ = Math.min(startZ, endZ);
            const maxZ = Math.max(startZ, endZ);
            const bottomY = startY - stepHeight;

            // Top surface vertices
            positions.push(0, startY, minZ);           // 0
            positions.push(platformWidth, startY, minZ); // 1
            positions.push(platformWidth, startY, maxZ); // 2
            positions.push(0, startY, maxZ);             // 3

            // Bottom surface vertices
            positions.push(0, bottomY, minZ);           // 4
            positions.push(platformWidth, bottomY, minZ); // 5
            positions.push(platformWidth, bottomY, maxZ); // 6
            positions.push(0, bottomY, maxZ);             // 7

            // Front face vertices (at maxZ)
            positions.push(0, bottomY, maxZ);           // 8
            positions.push(platformWidth, bottomY, maxZ); // 9
            positions.push(platformWidth, startY, maxZ); // 10
            positions.push(0, startY, maxZ);             // 11

            // Back face vertices (at minZ)
            positions.push(0, bottomY, minZ);           // 12
            positions.push(platformWidth, bottomY, minZ); // 13
            positions.push(platformWidth, startY, minZ); // 14
            positions.push(0, startY, minZ);             // 15

            // Left face vertices (at X=0)
            positions.push(0, bottomY, minZ);           // 16
            positions.push(0, bottomY, maxZ);           // 17
            positions.push(0, startY, maxZ);             // 18
            positions.push(0, startY, minZ);             // 19

            // Right face vertices (at X=platformWidth)
            positions.push(platformWidth, bottomY, minZ); // 20
            positions.push(platformWidth, bottomY, maxZ); // 21
            positions.push(platformWidth, startY, maxZ); // 22
            positions.push(platformWidth, startY, minZ); // 23

            // Add normals for all faces
            // Top surface normals (pointing up)
            for (let i = 0; i < 4; i++) normals.push(0, 1, 0);

            // Bottom surface normals (pointing down)
            for (let i = 0; i < 4; i++) normals.push(0, -1, 0);

            // Front face normals (pointing forward)
            for (let i = 0; i < 4; i++) normals.push(0, 0, 1);

            // Back face normals (pointing backward)
            for (let i = 0; i < 4; i++) normals.push(0, 0, -1);

            // Left face normals (pointing left)
            for (let i = 0; i < 4; i++) normals.push(-1, 0, 0);

            // Right face normals (pointing right)
            for (let i = 0; i < 4; i++) normals.push(1, 0, 0);

            // Add triangles for all faces
            // Top surface (reverse winding for upward-facing)
            addQuadTriangles(indices, baseIndex + 0, baseIndex + 3, baseIndex + 2, baseIndex + 1);

            // Bottom surface
            addQuadTriangles(indices, baseIndex + 4, baseIndex + 5, baseIndex + 6, baseIndex + 7);

            // Front face
            addQuadTriangles(indices, baseIndex + 8, baseIndex + 11, baseIndex + 10, baseIndex + 9);

            // Back face
            addQuadTriangles(indices, baseIndex + 12, baseIndex + 13, baseIndex + 14, baseIndex + 15);

            // Left face
            addQuadTriangles(indices, baseIndex + 16, baseIndex + 19, baseIndex + 18, baseIndex + 17);

            // Right face
            addQuadTriangles(indices, baseIndex + 20, baseIndex + 21, baseIndex + 22, baseIndex + 23);
        }

        function addStepToMesh(positions, indices, normals, currentHeight, nextHeight, currentDepth, nextDepth, width, offsetX, isForward) {
            const baseIndex = positions.length / 3;

            // Step top surface (rectangle) - offset by startX
            positions.push(offsetX, nextHeight, currentDepth);              // 0
            positions.push(offsetX + width, nextHeight, currentDepth);     // 1
            positions.push(offsetX + width, nextHeight, nextDepth);        // 2
            positions.push(offsetX, nextHeight, nextDepth);                // 3

            // Top surface normals (pointing up)
            for (let i = 0; i < 4; i++) normals.push(0, 1, 0);

            // Step front face (rectangle) - offset by startX
            positions.push(offsetX, currentHeight, currentDepth);          // 4
            positions.push(offsetX + width, currentHeight, currentDepth);  // 5
            positions.push(offsetX + width, nextHeight, currentDepth);     // 6
            positions.push(offsetX, nextHeight, currentDepth);             // 7

            // Front face normals
            for (let i = 0; i < 4; i++) normals.push(0, 0, -1);

            // Add triangles for top surface - adjust winding for backward stairs
            if (isForward) {
                addQuadTriangles(indices, baseIndex + 0, baseIndex + 3, baseIndex + 2, baseIndex + 1);
            } else {
                addQuadTriangles(indices, baseIndex + 0, baseIndex + 1, baseIndex + 2, baseIndex + 3);
            }

            // Add triangles for front face - reverse winding for backward stairs
            if (isForward) {
                addQuadTriangles(indices, baseIndex + 4, baseIndex + 7, baseIndex + 6, baseIndex + 5);
            } else {
                addQuadTriangles(indices, baseIndex + 7, baseIndex + 4, baseIndex + 5, baseIndex + 6);
            }
        }

        function addQuadTriangles(indices, p0, p1, p2, p3) {
            // First triangle
            indices.push(p0, p1, p2);
            // Second triangle
            indices.push(p0, p2, p3);
        }

        // UI Management
        function updateLevelsUI() {
            const container = document.getElementById('levelsContainer');
            container.innerHTML = '';

            stairLevels.forEach((level, index) => {
                const levelDiv = document.createElement('div');
                levelDiv.className = 'level-container';
                levelDiv.innerHTML = `
                    <div class="level-controls">
                        <span>Level ${index + 1}:</span>
                        <label>Steps:</label>
                        <input type="number" value="${level.stepCount}" onchange="updateStepCount(${index}, this.value)" min="1">
                    </div>
                `;
                container.appendChild(levelDiv);
            });

            updateCalculatedInfo();
        }

        function updateStepCount(levelIndex, value) {
            const steps = parseInt(value);
            if (steps > 0) {
                stairLevels[levelIndex].stepCount = steps;
                updateCalculatedInfo();
            }
        }

        function addLevel() {
            stairLevels.push({ stepCount: 8 });
            updateLevelsUI();
        }

        function removeLevel() {
            if (stairLevels.length > 1) {
                stairLevels.pop();
                updateLevelsUI();
            }
        }

        function updateCalculatedInfo() {
            const stairwellHeight = parseFloat(document.getElementById('stairwellHeight').value) || 2700;
            const totalSteps = stairLevels.reduce((sum, level) => sum + level.stepCount, 0);
            const totalPlatforms = Math.max(0, stairLevels.length - 1);
            const totalRises = totalSteps + totalPlatforms;

            const calculatedStepHeight = totalRises > 0 ? stairwellHeight / totalRises : 0;

            document.getElementById('calculatedInfo').innerHTML = `
                Total Steps: ${totalSteps} steps, ${totalPlatforms} platforms<br>
                Calculated Step Height: ${calculatedStepHeight.toFixed(1)} mm
            `;
        }

        function generateStair() {
            try {
                const stairwellHeight = parseFloat(document.getElementById('stairwellHeight').value);
                const stepLength = parseFloat(document.getElementById('stepLength').value);
                const stairWidth = parseFloat(document.getElementById('stairWidth').value);
                const platformWidth = parseFloat(document.getElementById('platformWidth').value);
                const platformDepth = parseFloat(document.getElementById('platformDepth').value);
                const clockwise = document.getElementById('clockwise').checked;

                // Validate inputs
                if (!stairwellHeight || !stepLength || !stairWidth || !platformWidth || !platformDepth) {
                    document.getElementById('status').textContent = 'Please fill in all fields with valid numbers';
                    return;
                }

                // Calculate step height
                const totalSteps = stairLevels.reduce((sum, level) => sum + level.stepCount, 0);
                const totalPlatforms = Math.max(0, stairLevels.length - 1);
                const totalRises = totalSteps + totalPlatforms;
                const stepHeight = stairwellHeight / totalRises;

                // Remove existing stair mesh
                if (stairMesh) {
                    scene.remove(stairMesh);
                }

                // Generate new mesh
                const geometry = generateLinearStairwellMesh(stairLevels, stepHeight, stepLength, stairWidth, platformWidth, platformDepth, clockwise);
                const material = new THREE.MeshLambertMaterial({
                    color: 0xcccccc,
                    side: THREE.DoubleSide
                });

                stairMesh = new THREE.Mesh(geometry, material);
                scene.add(stairMesh);

                // Adjust camera to view the stair
                adjustCamera(geometry);

                const direction = clockwise ? 'clockwise' : 'counter-clockwise';
                document.getElementById('status').textContent = `Generated ${direction} linear stairwell with ${stairLevels.length} levels, ${totalSteps} steps`;

            } catch (error) {
                document.getElementById('status').textContent = `Error: ${error.message}`;
            }
        }

        function adjustCamera(geometry) {
            geometry.computeBoundingBox();
            const box = geometry.boundingBox;

            const center = new THREE.Vector3();
            box.getCenter(center);

            const size = new THREE.Vector3();
            box.getSize(size);

            const maxDim = Math.max(size.x, size.y, size.z);
            const distance = maxDim * 2;

            camera.position.set(center.x + distance, center.y + distance, center.z + distance);
            controls.target.copy(center);
            controls.update();
        }

        function exportOBJ() {
            if (!stairMesh) {
                document.getElementById('status').textContent = 'No stair to export. Generate a stair first.';
                return;
            }

            const geometry = stairMesh.geometry;
            const positions = geometry.attributes.position.array;
            const indices = geometry.index.array;

            let objContent = '# Stair Generator OBJ Export - Units: meters\n\n';

            // Export vertices
            for (let i = 0; i < positions.length; i += 3) {
                const x = positions[i].toFixed(9);
                const y = positions[i + 1].toFixed(9);
                const z = positions[i + 2].toFixed(9);
                objContent += `v ${x} ${y} ${z}\n`;
            }

            objContent += '\n';

            // Export faces (triangles)
            for (let i = 0; i < indices.length; i += 3) {
                const v1 = indices[i] + 1;     // OBJ is 1-indexed
                const v2 = indices[i + 1] + 1;
                const v3 = indices[i + 2] + 1;
                objContent += `f ${v1} ${v2} ${v3}\n`;
            }

            // Download the file
            const blob = new Blob([objContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'stair.obj';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            document.getElementById('status').textContent = 'Exported stair.obj';
        }

        // Event listeners
        document.getElementById('stairwellHeight').addEventListener('input', updateCalculatedInfo);

        // Initialize the application
        function init() {
            initThreeJS();
            updateLevelsUI();
            generateStair(); // Generate default stair
        }

        // Start when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>